from distutils.core import setup, Extension
import numpy
from Cython.Distutils import build_ext


"""
Grid Subsampling module:
----------------------------------------
Description:
    Downsampling the given point cloud via Grid subsampling. Given a voxel 
    side length, each point are first mapped to the closest voxel in the 
    grid, then for each non-empty voxel, a sampled point is generated by
    calculate the mean coordinates and features of all points mapped to 
    the voxel, the corresponding label are taken as the label appears the 
    most time within points mapped to the voxel.

Usage:
    from <path to grid_subsampling.*.so file> import grid_subsampling

    grid_subsampling.compute(
        points,  # [N, 3] numpy array, whole point cloud
        features=None,  # [N, d] numpy array, features for each points
        classes=None,  # [N, k] numpy array, labels for each points
        sampleDl=0.1,  # float scalar, voxel side length
        method="barycenters",  # currently useless, just ignore it
        verbose=False  # bool scalar, almost useless, ignore it too
    )  
    # returns: [sub_points, sub_features, sub_classes]
"""
grid_subsampling_module = Extension(
    name="grid_subsampling",
    sources=["grid_subsampling/cloud.cpp",
             "grid_subsampling/grid_subsampling.cpp",
             "grid_subsampling/wrapper.cpp"],
    language="c++",
    include_dirs=[numpy.get_include()],
    extra_compile_args=["-std=c++11", "-D_GLIBCXX_USE_CXX11_ABI=0"]
)


"""
Nearest Meighbors module:
----------------------------------------
Description:
    Given global points 'pts', query points 'queries', and num neighbors
    'k', this module calculate the index of KNN points w.r.t. each global
    points. (The principle is to build a KDTree for each point cloud in
    the batch, and the do KNN search via generated KDTree.)

Usage:
    from <path to nearest_neighbors.*.so file> import nearest_neighbors

    nearest_neighbors.knn(
        pts,       # [N, d] numpy array, global points
        queries,   # [M, d] numpy array, query points
        K,         # int scalar, num neighbors
        omp=False  # whether to use OpenMP features, i.e. parallel computing
    )
    # returns: 
    #   indices: [M, K], NN-index of each queries

    nearest_neighbors.knn_batch(
        pts,        # [B, N, d] numpy array, global points
        querires,   # [B, M, d] numpy array, query points
        K,          # int scalar, num neighbors
        omp=False,  # same as above
    )
    # returns: 
    #   indices: [B, M, K], NN-index of each queries

    nearest_neighbors.knn_batch_distance_pick(
        pts,       # [B, N, d] numpy array, global points
        nqueries,  # int scalar, num query points
        K,         #  int scalar, num neighbors
        omp=False  # same as above
    )
    # returns:
    #    queries: [B, M, d], relatively "uniform sampled" queries points.
    #    indices: [B, M, K], NN-idx of sampled queries
"""
nearest_neighbors_module = Extension(
    name="nearest_neighbors",
    sources=["nearest_neighbors/knn.pyx",
             "nearest_neighbors/knn_.cxx"],
    language="c++",
    include_dirs=[numpy.get_include()],
    extra_compile_args=["-std=c++11", "-fopenmp"],
    extra_link_args=["-std=c++11", "-fopenmp"]
)


setup(name="CustomOp",
      version="0.0.1",
      description="Package of custom operation.",
      ext_modules=[grid_subsampling_module, 
                   nearest_neighbors_module],
      cmdclass={"build_ext": build_ext})


# To build all extension of custom_op, use "python setup.py build_ext --inplace", 
# it will generate a *.so file for each extension listed in ext_modules.
